#include <lwk/linkage.h>
#include <arch/ptrace.h>


/**
 * This is the common entry point for exceptions.  Exceptions are generally
 * error conditions, e.g., divide by 0, machine check, etc.  The x86_64
 * architecture defines a number of standard exceptions in the interrupt vector
 * range [0,31].
 *
 * Upon entry, this function expects the stack frame to look like:
 * (NOTE: The stack is growing down)
 * (NOTE: This assumes the exception was triggered while user space code was
 *        executing.  If the kernel was executing when the exception fired,
 *        SS and RSP are not pushed onto the stack by the CPU. The eventual
 *        IRETQ instruction inspects RFLAGS to determine if SS and RSP need
 *        to be popped, so we don't have to do anything special.)
 * 
 *                       [...]
 *                       SS         (stack segment selector)
 *                       RSP        (stack pointer)
 *                       RFLAGS     (flags register)
 *                       CS         (code segment selector)
 *                       RIP        (instruction pointer)
 *                       ERROR_CODE (error code)
 *    stack pointer  ->  RAX        (saved RAX, RAX now holds the handler addr)
 *
 * The function pushes the rest of the registers to the stack in the same
 * format as the Linux pt_regs structure (see /include/arch-x86_64/ptrace.h)
 * and then calls the handler function whose address is stored in RAX.  The
 * handler function is typically a higher-level C function and expects to be
 * passed a pointer to the pt_regs structure setup by this function as well as
 * the original error_code saved by the CPU control unit, if there was one (not
 * all exceptions push an error_code to the stack... in that case, the handler
 * is passed 0 as the error code argument).
 *
 * Before calling the handler function, the stack frame looks like:
 *
 *                       [...]
 *                       SS         (stack segment selector)
 *                       RSP        (stack pointer)
 *                       RFLAGS     (flags register)
 *                       CS         (code segment selector)
 *                       RIP        (instruction pointer)
 *                       -1         (flags this as an exception)
 *                       RDI        (NOTE: this was RAX on entry, we move it)
 *                       RSI
 *                       RDX
 *                       RCX
 *                       RAX        (saved RAX)
 *                       R8
 *                       R9
 *                       R10
 *                       R11
 *                       RBX
 *                       RBP
 *                       R12
 *                       R13
 *                       R14
 *    stack pointer  ->  R15
 *
 * After the handler function returns, this function restores the stack to its
 * pre-exception state, restores the CPU state to its pre-exception state,
 * and returns to the program that was running when the exception occurred.
 */
ENTRY(exception_entry)
	cld				/* Kernel expects direction flag to be cleared */

	/*
	 * Save registers on stack (in the same format as 'struct pt_regs')
	 */
	subq  $14*8,%rsp		/* Stack pointer can now be considered a 'struct pt_regs *' */
	movq %rsi,13*8(%rsp)			/* Save RSI in stack frame */
	movq 14*8(%rsp),%rsi		/* Now that RSI saved, stash pt_regs->RDI in it (this is the saved RAX value) */
	movq %rdx,12*8(%rsp)			/* Save RDX in stack frame */
	movq %rcx,11*8(%rsp)			/* Save RCX in stack frame */
	movq %rsi,10*8(%rsp)			/* Save RAX in stack frame, NOTE: RAX was saved in RSI above */
	movq %r8, 9*8(%rsp)			/* Save R8  in stack frame */
	movq %r9, 8*8(%rsp)			/* Save R9  in stack frame */
	movq %r10,7*8(%rsp)			/* Save R10 in stack frame */
	movq %r11,6*8(%rsp)			/* Save R11 in stack frame */
	movq %rbx,5*8(%rsp)			/* Save RBX in stack frame */
	movq %rbp,4*8(%rsp)			/* Save RBP in stack frame */
	movq %r12,3*8(%rsp)			/* Save R12 in stack frame */
	movq %r13,2*8(%rsp)			/* Save R13 in stack frame */
	movq %r14,1*8(%rsp)			/* Save R14 in stack frame */
	movq %r15,(%rsp)			/* Save R15 in stack frame */
	movq %rdi,14*8(%rsp)			/* Save RDI in stack frame */

	/*
	 * Determine if this exception was generated by the kernel or user
	 * mode.  If kernel mode, we do not need to call the SWAPGS instruction
	 * to load the GS register with the kernel value... doing so would be
	 * bad... dogs and cats living together... mass hysteria.  When in
	 * kernel mode, the GS segment register is setup to reference the kernel
	 * PDA 'Per-processor data area'... basically a quick way to get at
	 * per-CPU data.  When in user mode, GS can't continue to point to it.
	 */
	xorl %ebx,%ebx			/* Use EBX as a boolean: 0=need SWAPGS, 1=don't need it */
	testl $3,CS(%rsp)		/* determine if we came from the kernel */
	je  exception_kernelspace

exception_swapgs:
	swapgs				/* Swaps GS register with value in KernelGSbase MSR */
exception_after_swapgs:

	/*
	 * Setup argments for handler function
	 */
	movq %rsp,%rdi			/* Argument 1: 'struct pt_regs *' */
	movq ERROR_CODE(%rsp),%rsi	/* Argument 2: actual error_code, or 0 for exceptions without error_code */
	movq $-1,ERROR_CODE(%rsp)	/* Flag this as an exception by setting error_code/orig_rax to -1 */

	/*
	 * Call the exception handler... finally!
	 */
	call *%rax

exception_exit:

	/*
	 * Call SWAPGS, if necessary.  EBX is a boolean: 0=need SWAPGS, 1=don't need it.
	 */
	testl %ebx,%ebx			/* Sets zero flag if EBX=0 */
	jne exception_restore_regs	/* If zero flag set, don't need SWAPGS */
	swapgs

	/*
	 * Restore registers
	 */
exception_restore_regs:
	movq  0*8(%rsp),%r15			/* Restore R15 from stack frame */
        movq  1*8(%rsp),%r14			/* Restore R14 from stack frame */
        movq  2*8(%rsp),%r13			/* Restore R13 from stack frame */
        movq  3*8(%rsp),%r12			/* Restore R12 from stack frame */
        movq  4*8(%rsp),%rbp			/* Restore RBP from stack frame */
        movq  5*8(%rsp),%rbx			/* Restore RBX from stack frame */
        movq  6*8(%rsp),%r11			/* Restore R11 from stack frame */
        movq  7*8(%rsp),%r10			/* Restore R10 from stack frame */
        movq  8*8(%rsp),%r9			/* Restore R9  from stack frame */
        movq  9*8(%rsp),%r8			/* Restore R8  from stack frame */
        movq 10*8(%rsp),%rax			/* Restore RAX from stack frame */
        movq 11*8(%rsp),%rcx			/* Restore RCX from stack frame */
        movq 12*8(%rsp),%rdx			/* Restore RDX from stack frame */
        movq 13*8(%rsp),%rsi			/* Restore RSI from stack frame */
        movq 14*8(%rsp),%rdi			/* Restore RDI from stack frame */
        addq $16*8,%rsp			/* Restore stack pointer... it now points to the return address, RIP */

	/*
	 * Return to the program that was executing when the exception occurred.
	 * The stack pointer now points to RIP in the stack frame (see stack
	 * frame layout in comment above).  IRETQ pops and restores RIP, CS,
	 * RFLAGS.  If RFLAGS specifiy that a privilege level change is needed,
	 * RSP and SS are also popped and restored.  Control is then transfered
	 * back to the program that was executing when the exception occurred
	 * (i.e., instruction at RIP).
	 */
	iretq

exception_kernelspace:
	incl %ebx			/* Set boolean, we don't need a SWAPGS */
	jmp exception_after_swapgs
/*
 * End of exception_enter()
 */


/**
 * For exceptions that do not have an error_code pushed onto the stack by the
 * CPU control unit when the exception occurs.  We compensate by pushing a dummy
 * error_code (0) onto the stack.
 */
	.macro exception handler_name
	pushq $0			/* Push dummy error code onto stack */
	pushq %rax			/* Push pristine RAX onto stack */
	leaq  \handler_name(%rip),%rax	/* Stash handler address in RAX */
	jmp exception_entry
	.endm


/**
 * For exceptions that do have an error_code pushed onto the stack by the
 * CPU control unit when the exception occurs.
 */
	.macro exception_with_error_code handler_name
	pushq %rax			/* push pristine RAX onto stack */
	leaq  \handler_name(%rip),%rax	/* stash handler address in RAX */
	jmp exception_entry
	.endm


/**
 * x86_64 architecture defined exceptions.
 */
ENTRY(divide_error)
	exception do_divide_error
ENTRY(nmi)
	exception do_nmi
ENTRY(int3)
	exception do_int3
ENTRY(overflow)
	exception do_overflow
ENTRY(bounds)
	exception do_bounds
ENTRY(invalid_op)
	exception do_invalid_op
ENTRY(device_not_available)
	exception do_device_not_available
ENTRY(double_fault)
	exception_with_error_code do_double_fault
ENTRY(coprocessor_segment_overrun)
	exception do_coprocessor_segment_overrun
ENTRY(invalid_TSS)
	exception_with_error_code do_invalid_TSS
ENTRY(segment_not_present)
	exception_with_error_code do_segment_not_present
ENTRY(stack_segment)
	exception_with_error_code do_stack_segment
ENTRY(general_protection)
	exception_with_error_code do_general_protection
ENTRY(page_fault)
	exception_with_error_code do_page_fault
ENTRY(spurious_interrupt_bug)
	exception do_spurious_interrupt_bug
ENTRY(coprocessor_error)
	exception do_coprocessor_error
ENTRY(alignment_check)
	exception_with_error_code do_alignment_check
ENTRY(machine_check)
	exception do_machine_check
ENTRY(simd_coprocessor_error)
	exception do_simd_coprocessor_error

