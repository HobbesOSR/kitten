Quick Start
===========
    make config  (or make menuconfig)
    make isoimage
    qemu-system-x86_64 -cdrom arch/x86_64/boot/image.iso -serial stdio -smp 4

    What you should see:
        A bunch of kernel initialization messages print to the console,
        followed by:

            <6>Loading initial user-level task (init_task)...
            <0>Unhandled Interrupt! (vector=52, isa_irq=4)
            <8>(init_task) Hello, world!
            <8>(init_task) Arguments:
            <8>(init_task)   argv[0] = init_task
            <8>(init_task)   argv[1] = one
            <8>(init_task)   argv[2] = two
            <8>(init_task)   argv[3] = three
            <8>(init_task) Environment Variables:
            <8>(init_task)   envp[0] = one=1
            <8>(init_task)   envp[1] = two=2
            <8>(init_task)   envp[2] = three=3
            [... A bunch of test messages, ommitted here]
            <8>(init_task) Spinning forever...
            <8>(cpu0-task)    Meow!
            <8>(init_task)    Meow!
            <8>(cpu1-task)    Meow!
            <8>(cpu2-task)    Meow!
            <8>(cpu3-task)    Meow!

        The source code for the hello world init_task is at
        user/hello_world/hello_world.c
 

Overview
========
    Kitten is a lightweight kernel (LWK) operating system designed to be used
    on the compute nodes of distributed memory supercomputers. At this point,
    Kitten is, well, still a kitten, but eventually our intent is for it to
    be used on systems consisting of tens or hundreds of thousands of
    multi-socket, multi-core compute nodes (i.e., mega-core systems). The
    primary goal of Kitten is to enable supercomputer applications to scale
    to significantly higher node counts and perform substantially better
    than is possible with general-purpose compute node operating systems,
    such as Linux. Kitten is based on Linux in part, but makes different
    design choices that are targeted at scalability (low noise, deterministic
    behavior) and performance (physically contiguous memory layout,
    transparent large pages, novel techniques for taking better advantage of
    multi-core processors, like SMARTMAP).

    Please see our wiki at http://software.sandia.gov/trac/kitten for more
    information.

    Features:
        * Open Source (GPL)
        * New LWK codebase partially derived from Linux, familiar
          organization and build process
        * Fully symmetric kernel, locking used to protect shared data
        * Multiple processes and threads per core
        * Partial Linux ABI support (what matters, similar to IBM's CNK)
        * User-space uses standard system Glibc
        * SMARTMAP memory mapping (see SC08 paper) to enable single-copy
          intra-node MPI messaging. This significantly reduces intra-node
          memory bandwidth requirements.
        * Guest OS support (when linked with the V3VEE project's
          Palacios hypervisor, http://v3vee.org/download)
        * lwIP TCP/IP stack (http://www.sics.se/~adam/lwip/) with
          ne2k and SeaStar drivers


Platforms Supported
===================
    Emulators:
       qemu-system-x86_64
       kvm (running on a 64-bit x86 system)
       virtualbox (with a bit of configuration, be sure to enable IO APIC)
    Real Hardware:
       Standard PC-compatible 64-bit x86 systems
           - Tested on a Core2 Duo Laptop (2 CPUs)
           - Tested on a 4 socket dual-core Opteron system (8 CPUs)
       Cray XT
           - XT3: 1 socket dual-core Opteron compute nodes (2 CPUs)
           - XT4: 1 socket quad-core Opteron compute nodes (4 CPUs)
           - XT5: 2 socket quad-core Opteron compute nodes (8 CPUs)


External builds
===============

It is possible to build object files separate from the source tree
using the Linux kbuild system.

	mkdir /tmp/lwk-build
	make O=/tmp/lwk-build menuconfig
	make -C /tmp/lwk-build vmlwk.bin init_task

There will be some warnings about targets being over-ridden,
but you can ignore them.


Modules
=======

Large pieces of code that do not have any direct down-calls from the
rest of the kernel can be built as external modules.  The init functions
in the modules will be called at the appropriate time for the different
device classes, or in a catch-all "module" class before the late init.

To build a module, create a Makefile in the module directory:

	obj-y := foo.o bar.o

And run:

	make -C $PATH_TO_KITTEN_OBJ M=`pwd`

This will create built-in.o that can then be copied to
$PATH_TO_KITTEN_OBJ/modules/foo.o and then kitten should be
rebuilt.

If you want to get fancier, you can also add this target to allow
a local build via 'make install O=$PATH_TO_KITTEN_OBJ':

install:
	@if [ -z "$O" ]; then echo >&2 "O must be defined"; exit 1; fi
	$(MAKE) -C $O M=`pwd`
	cp built-in.o $O/modules/palacios-mod.o


Instructions for Booting on Real Hardware
=========================================
    PC-compatible hardware:
        Do 'make config' and choose:
            System Architecture ---> PC-compatible (the default)
        Rebuild, and use the following files:
            kernel image: ./arch/x86_64/boot/bzImage
            initrd:       ./init_task

    Cray XT hardware:
	These instructions are for 2.0 management system; 2.1 requires
	a different set of steps.

        Do 'make config' and choose:
            System Architecture ---> Red Storm (Cray XT3/XT4)
        Rebuild, and copy the following files to /bootimages/cageN/CNL0/:
            kernel image: ./vmlwk.bin
            initrd:       ./init_task
        Update the /bootimages/cageN/CNL0.load file:
CNL0/vmlwk.bin 0x100000
CNL0/parameters-vmlwk 0x90800
CNL0/init_task 0xFA00000

	Create the /bootimages/cageN/CNL0/parameters-vmlwk:
console=rcal0 net=seastar

	Run 'create_bi cageN'
	Reboot the nodes 'xtbootsys --reboot --partition p4 c5-0c0s1n0'
